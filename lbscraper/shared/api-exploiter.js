/**
 * API Exploiter for Leaderboard Scraper
 * 
 * Discovers and chains API calls for maximum data extraction.
 * 
 * Features:
 * - Detect parameterized URL patterns (keywords, IDs, pagination)
 * - Substitute keywords/IDs to generate variant URLs
 * - Chain API calls (use IDs from one endpoint in another)
 * - Increase pagination to get more results
 * - Extract providers/sites from discovery endpoints
 * 
 * CRITICAL: The API listener (network interception) MUST be active during ALL operations
 */

const { log } = require('./utils');
const { makeHttpRequest, makeHttpRequestWithHeaders } = require('./api-patterns');

// Common path parts that should NOT be treated as provider keywords
const COMMON_PATH_PARTS = new Set([
  'API', 'V1', 'V2', 'V3', 'DATA', 'PUBLIC', 'PRIVATE', 'LIST', 'GET', 'POST',
  'LEADERBOARD', 'LEADERBOARDS', 'RANKING', 'RANKINGS', 'WINNER', 'WINNERS',
  'USER', 'USERS', 'INFO', 'ACTIVE', 'CURRENT', 'PREVIOUS', 'HISTORY',
  'LEADERS', 'ENTRIES', 'RESULTS', 'STATS', 'STATISTICS', 'REWARDS',
  'HTTP', 'HTTPS', 'WWW', 'COM', 'GG', 'IO', 'NET', 'ORG'
]);

/**
 * Check if a path part is a common word (not a provider keyword)
 */
function isCommonPathPart(part) {
  return COMMON_PATH_PARTS.has(part.toUpperCase());
}

// ============================================================================
// PATTERN DETECTION
// ============================================================================

/**
 * URL pattern types
 */
const PATTERN_TYPES = {
  PATH_KEYWORD: 'path-keyword',     // /leaderboard/{SITE}/data
  QUERY_KEYWORD: 'query-keyword',   // ?site=GAMDOM
  PAGINATION: 'pagination',         // ?take=10
  ID_REFERENCE: 'id-reference',     // ?leaderboardId=xxx
  DATE_PARAM: 'date-param'          // ?month=12&year=2025
};

/**
 * Detect parameterized patterns in a URL
 * @param {string} url - API URL to analyze
 * @returns {Array} - Array of detected patterns
 */
function detectApiPatterns(url) {
  if (!url || typeof url !== 'string') return [];
  
  const patterns = [];
  
  // Pattern: keyword in URL path 
  // Examples:
  //   /leaderboard/list-winner/GAMDOM/public
  //   /leaderboard/GAMDOM/data
  //   /api/leaderboard/PACKDRAW/entries
  // 
  // Look for UPPERCASE keywords that look like provider names (not "list-winner", "public", etc)
  const pathParts = url.split('/');
  for (let i = 0; i < pathParts.length; i++) {
    const part = pathParts[i];
    // Check if this part looks like a provider keyword (UPPERCASE, reasonable length, not a common word)
    if (part && 
        part.length >= 3 && 
        part.length <= 30 &&
        /^[A-Z][A-Z0-9_-]*$/i.test(part) &&  // Alphanumeric
        part === part.toUpperCase() &&        // Is uppercase
        !isCommonPathPart(part)) {            // Not a common path segment
      patterns.push({
        type: PATTERN_TYPES.PATH_KEYWORD,
        url,
        value: part,
        pathIndex: i,
        example: `.../${part}/...`
      });
    }
  }
  
  // Pattern: keyword as query param
  // Examples:
  //   ?casinoProvider=GAMDOM
  //   ?site=PACKDRAW&viewState=expanded
  //   ?provider=LOOTBOX
  const keywordParams = ['site', 'provider', 'casino', 'casinoprovider', 'casinoproviders', 'platform', 'name'];
  for (const param of keywordParams) {
    const regex = new RegExp(`[?&](${param})=([^&]+)`, 'i');
    const match = url.match(regex);
    if (match && match[2] && match[2].length >= 2) {
      patterns.push({
        type: PATTERN_TYPES.QUERY_KEYWORD,
        url,
        param: match[1], // Use actual case from URL
        value: match[2], // The keyword value (e.g., "GAMDOM")
        example: `?${match[1]}=${match[2]}`
      });
    }
  }
  
  // Pattern: pagination
  const paginationParams = ['take', 'limit', 'count', 'pagesize', 'size'];
  for (const param of paginationParams) {
    const regex = new RegExp(`[?&]${param}=(\\d+)`, 'i');
    const match = url.match(regex);
    if (match) {
      patterns.push({
        type: PATTERN_TYPES.PAGINATION,
        url,
        param,
        value: parseInt(match[1]),
        regex,
        example: `?${param}={VALUE}`
      });
    }
  }
  
  // Pattern: ID reference
  const idParams = ['leaderboardid', 'id', 'boardid', 'uuid'];
  for (const param of idParams) {
    const regex = new RegExp(`[?&]${param}=([^&]+)`, 'i');
    const match = url.match(regex);
    if (match) {
      patterns.push({
        type: PATTERN_TYPES.ID_REFERENCE,
        url,
        param,
        value: match[1],
        regex,
        example: `?${param}={ID}`
      });
    }
  }
  
  // Pattern: date params
  const dateParams = ['month', 'year'];
  for (const param of dateParams) {
    const regex = new RegExp(`[?&]${param}=(\\d+)`, 'i');
    const match = url.match(regex);
    if (match) {
      patterns.push({
        type: PATTERN_TYPES.DATE_PARAM,
        url,
        param,
        value: parseInt(match[1]),
        regex,
        example: `?${param}={VALUE}`
      });
    }
  }
  
  return patterns;
}

// ============================================================================
// URL VARIANT GENERATION
// ============================================================================

/**
 * Build variant URLs by substituting keywords
 * IMPORTANT: Preserve the ENTIRE URL structure - only swap the keyword value!
 * 
 * @param {string} baseUrl - Base URL with keyword
 * @param {Array} keywords - Keywords to substitute
 * @param {Object} pattern - Pattern info
 * @returns {Array} - Array of variant URLs
 */
function buildKeywordVariants(baseUrl, keywords, pattern) {
  const variants = [];
  const originalKeyword = pattern.value; // The keyword we detected in the original URL
  
  if (!originalKeyword) {
    log('WARN', `No original keyword found in pattern for ${baseUrl}`);
    return variants;
  }
  
  for (const keyword of keywords) {
    if (!keyword) continue;
    
    // Skip if same as original (case-insensitive)
    if (keyword.toLowerCase() === originalKeyword.toLowerCase()) continue;
    
    let newUrl = baseUrl;
    
    if (pattern.type === PATTERN_TYPES.PATH_KEYWORD) {
      // Use pathIndex if available for precise replacement
      if (pattern.pathIndex !== undefined) {
        try {
          const urlObj = new URL(baseUrl);
          const pathParts = urlObj.pathname.split('/');
          pathParts[pattern.pathIndex] = keyword.toUpperCase();
          urlObj.pathname = pathParts.join('/');
          newUrl = urlObj.toString();
        } catch (e) {
          // Fallback to string replacement
          newUrl = baseUrl.replace(
            new RegExp(`/${escapeRegex(originalKeyword)}(/|$)`, 'gi'),
            `/${keyword.toUpperCase()}$1`
          );
        }
      } else {
        // Fallback: Simple string replacement - replace ONLY the keyword, preserve everything else
        newUrl = baseUrl.replace(
          new RegExp(`/${escapeRegex(originalKeyword)}(/|$)`, 'gi'),
          `/${keyword.toUpperCase()}$1`
        );
      }
    } else if (pattern.type === PATTERN_TYPES.QUERY_KEYWORD) {
      // Replace query param value - preserve ALL other params
      // Example: ?casinoProvider=GAMDOM&viewState=expanded â†’ ?casinoProvider=PACKDRAW&viewState=expanded
      newUrl = baseUrl.replace(
        new RegExp(`(${escapeRegex(pattern.param)}=)${escapeRegex(originalKeyword)}(?=&|$)`, 'gi'),
        `$1${keyword.toUpperCase()}`
      );
    }
    
    // Validate the replacement worked and URL is different
    if (newUrl !== baseUrl && newUrl.length > 0) {
      variants.push({
        url: newUrl,
        keyword,
        originalKeyword,
        source: 'keyword-substitution',
        patternType: pattern.type
      });
    }
  }
  
  return variants;
}

/**
 * Escape special regex characters in a string
 */
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Build variant URLs by substituting IDs
 * @param {string} baseUrl - Base URL with ID
 * @param {Array} ids - IDs to substitute
 * @param {Object} pattern - Pattern info
 * @returns {Array} - Array of variant URLs
 */
function buildIdVariants(baseUrl, ids, pattern) {
  const variants = [];
  
  for (const id of ids) {
    if (!id) continue;
    
    const regex = new RegExp(`([?&]${pattern.param}=)[^&]+`, 'i');
    const newUrl = baseUrl.replace(regex, `$1${id}`);
    
    if (newUrl !== baseUrl) {
      variants.push({
        url: newUrl,
        id,
        source: 'id-substitution',
        patternType: pattern.type
      });
    }
  }
  
  return variants;
}

/**
 * Build variant URLs with increased pagination
 * @param {string} baseUrl - Base URL
 * @param {Object} pattern - Pattern info
 * @param {number} maxTake - Maximum take value (default 100)
 * @returns {Array} - Array of variant URLs
 */
function buildPaginationVariants(baseUrl, pattern, maxTake = 100) {
  const regex = new RegExp(`([?&]${pattern.param}=)\\d+`, 'i');
  const newUrl = baseUrl.replace(regex, `$1${maxTake}`);
  
  if (newUrl !== baseUrl) {
    return [{
      url: newUrl,
      take: maxTake,
      source: 'pagination-increase',
      patternType: pattern.type
    }];
  }
  
  return [];
}

/**
 * Build variant URLs with different date parameters
 * @param {string} baseUrl - Base URL
 * @param {Object} pattern - Pattern info
 * @param {number} startYear - Start year (default 2025)
 * @param {number} startMonth - Start month (default 1)
 * @returns {Array} - Array of variant URLs
 */
function buildDateVariants(baseUrl, pattern, startYear = 2025, startMonth = 1) {
  const variants = [];
  const now = new Date();
  let currentYear = now.getFullYear();
  let currentMonth = now.getMonth() + 1;
  
  // Generate variants going back in time
  while (currentYear > startYear || (currentYear === startYear && currentMonth >= startMonth)) {
    const yearRegex = /([?&]year=)\d+/i;
    const monthRegex = /([?&]month=)\d+/i;
    
    let newUrl = baseUrl;
    newUrl = newUrl.replace(yearRegex, `$1${currentYear}`);
    newUrl = newUrl.replace(monthRegex, `$1${currentMonth}`);
    
    if (newUrl !== baseUrl) {
      variants.push({
        url: newUrl,
        year: currentYear,
        month: currentMonth,
        source: 'date-substitution',
        patternType: pattern.type
      });
    }
    
    // Go back one month
    currentMonth--;
    if (currentMonth < 1) {
      currentMonth = 12;
      currentYear--;
    }
  }
  
  return variants;
}

// ============================================================================
// DATA EXTRACTION FROM RESPONSES
// ============================================================================

/**
 * Extract provider names from API response
 * @param {Object} body - API response body
 * @returns {Array} - Array of provider names
 */
function extractProviders(body) {
  const providers = new Set();
  
  if (!body) return [];
  
  // Response is array of strings
  if (Array.isArray(body)) {
    for (const item of body) {
      if (typeof item === 'string' && item.length >= 2 && item.length <= 50) {
        providers.add(item.toLowerCase());
      }
      if (typeof item === 'object' && item !== null) {
        if (item.name) providers.add(item.name.toLowerCase());
        if (item.provider) providers.add(item.provider.toLowerCase());
        if (item.site) providers.add(item.site.toLowerCase());
        if (item.slug) providers.add(item.slug.toLowerCase());
      }
    }
  }
  
  // Response has providers/sites field
  if (body.providers) {
    const p = Array.isArray(body.providers) ? body.providers : [body.providers];
    p.forEach(x => typeof x === 'string' && providers.add(x.toLowerCase()));
  }
  if (body.sites) {
    const s = Array.isArray(body.sites) ? body.sites : [body.sites];
    s.forEach(x => typeof x === 'string' && providers.add(x.toLowerCase()));
  }
  if (body.data && Array.isArray(body.data)) {
    for (const item of body.data) {
      if (item.name) providers.add(item.name.toLowerCase());
      if (item.site) providers.add(item.site.toLowerCase());
    }
  }
  
  return Array.from(providers).filter(p => p.length >= 2);
}

/**
 * Extract IDs from API response
 * @param {Object} body - API response body
 * @returns {Array} - Array of IDs
 */
function extractIds(body) {
  const ids = new Set();
  
  const findIds = (obj, depth = 0) => {
    if (depth > 5 || !obj) return;
    
    if (Array.isArray(obj)) {
      obj.forEach(item => findIds(item, depth + 1));
    } else if (typeof obj === 'object') {
      for (const [key, value] of Object.entries(obj)) {
        const keyLower = key.toLowerCase();
        if (['id', 'leaderboardid', 'boardid', 'uuid', '_id'].includes(keyLower) && value) {
          ids.add(String(value));
        }
        findIds(value, depth + 1);
      }
    }
  };
  
  findIds(body);
  return Array.from(ids);
}

/**
 * Extract sites from error responses
 * Many APIs reveal valid site names in error messages
 * @param {Object} response - API response (may be error)
 * @returns {Array} - Array of discovered site names
 */
function extractSitesFromError(response) {
  const sites = [];
  
  if (!response) return sites;
  
  // Check error message
  if (response.error?.message) {
    // Pattern: "Invalid site. Valid sites are: luxdrop, gamdom, stake"
    const match = response.error.message.match(/valid\s+sites?[:\s]+([a-z,\s]+)/i);
    if (match) {
      sites.push(...match[1].split(',').map(s => s.trim().toLowerCase()));
    }
  }
  
  // Check for arrays of valid options
  if (response.availableSites) sites.push(...response.availableSites);
  if (response.validSites) sites.push(...response.validSites);
  if (response.sites) sites.push(...(Array.isArray(response.sites) ? response.sites : [response.sites]));
  if (response.allowedSites) sites.push(...response.allowedSites);
  if (response.supportedSites) sites.push(...response.supportedSites);
  
  // Check message field
  if (response.message) {
    const match = response.message.match(/(?:valid|available|allowed|supported)\s+(?:sites?|providers?)[:\s]+([a-z,\s]+)/i);
    if (match) {
      sites.push(...match[1].split(',').map(s => s.trim().toLowerCase()));
    }
  }
  
  return sites.filter(s => s && s.length >= 2 && s.length <= 50);
}

// ============================================================================
// API CHAINING
// ============================================================================

/**
 * Chain API calls: analyze responses and generate all possible variant URLs
 * @param {Array} networkData - Captured network responses
 * @param {Array} keywords - Known keywords/providers
 * @param {Object} config - Configuration
 * @returns {Object} - { allKeywords, allIds, urlVariants }
 */
function chainApiCalls(networkData, keywords = [], config = {}) {
  const responses = networkData?.rawJsonResponses || networkData?.responses || [];
  
  const allProviders = new Set(keywords.map(k => k.toLowerCase()));
  const allIds = new Set();
  const urlVariants = [];
  const processedUrls = new Set();
  
  // Step 1: Analyze all responses to extract providers and IDs
  for (const response of responses) {
    const url = response.url;
    const body = response.data || response.body;
    
    // Check for provider list endpoints
    if (url && (url.includes('providers') || url.includes('active'))) {
      const providers = extractProviders(body);
      providers.forEach(p => allProviders.add(p));
      
      if (providers.length > 0) {
        log('API', `Found ${providers.length} providers from ${url.substring(0, 60)}...`);
      }
    }
    
    // Extract IDs from any response
    const ids = extractIds(body);
    ids.forEach(id => allIds.add(id));
    
    // Check for sites revealed in errors
    const errorSites = extractSitesFromError(body);
    errorSites.forEach(s => allProviders.add(s));
    
    if (errorSites.length > 0) {
      log('API', `Error response revealed ${errorSites.length} sites: ${errorSites.join(', ')}`);
    }
  }
  
  // Step 2: Generate variant URLs using all discovered info
  const allKeywords = Array.from(allProviders);
  const allIdList = Array.from(allIds);
  
  log('API', `Chaining with ${allKeywords.length} keywords: ${allKeywords.slice(0, 5).join(', ')}${allKeywords.length > 5 ? '...' : ''}`);
  
  for (const response of responses) {
    const url = response.url;
    if (!url || processedUrls.has(url)) continue;
    processedUrls.add(url);
    
    const patterns = detectApiPatterns(url);
    
    if (patterns.length > 0) {
      log('API', `URL ${url.substring(0, 80)}... has ${patterns.length} pattern(s)`);
      for (const p of patterns) {
        log('API', `  Pattern: ${p.type} = "${p.value}" (${p.example || ''})`);
      }
    }
    
    for (const pattern of patterns) {
      // Generate keyword variants
      if (pattern.type === PATTERN_TYPES.PATH_KEYWORD || pattern.type === PATTERN_TYPES.QUERY_KEYWORD) {
        const variants = buildKeywordVariants(url, allKeywords, pattern);
        if (variants.length > 0) {
          log('API', `  Generated ${variants.length} keyword variants from ${pattern.value}`);
          // Log first variant as example
          if (variants[0]) {
            log('API', `    Example: ${variants[0].url.substring(0, 100)}...`);
          }
        }
        urlVariants.push(...variants);
      }
      
      // Generate ID variants
      if (pattern.type === PATTERN_TYPES.ID_REFERENCE) {
        const variants = buildIdVariants(url, allIdList, pattern);
        urlVariants.push(...variants);
      }
      
      // Generate pagination variants
      if (pattern.type === PATTERN_TYPES.PAGINATION) {
        const variants = buildPaginationVariants(url, pattern, config.maxTake || 100);
        urlVariants.push(...variants);
      }
      
      // Generate date variants for historical farming
      if (pattern.type === PATTERN_TYPES.DATE_PARAM && config.enableHistorical) {
        const variants = buildDateVariants(url, pattern, 2025, 1);
        urlVariants.push(...variants);
      }
    }
  }
  
  // Deduplicate variants
  const uniqueVariants = [];
  const seenUrls = new Set();
  
  for (const variant of urlVariants) {
    if (!seenUrls.has(variant.url)) {
      seenUrls.add(variant.url);
      uniqueVariants.push(variant);
    }
  }
  
  log('API', `Generated ${uniqueVariants.length} unique URL variants from ${allKeywords.length} keywords and ${allIdList.length} IDs`);
  
  return {
    allKeywords,
    allIds: allIdList,
    urlVariants: uniqueVariants
  };
}

/**
 * Execute a list of variant URLs and collect results
 * @param {Array} variants - URL variants to try
 * @param {Object} headers - Headers to use
 * @param {Object} config - Configuration
 * @returns {Promise<Array>} - Array of successful responses
 */
async function executeVariants(variants, headers = null, config = {}) {
  const results = [];
  const delay = config.delayMs || 2000; // 2 second delay between requests
  
  for (const variant of variants) {
    try {
      const response = headers 
        ? await makeHttpRequestWithHeaders(variant.url, headers, { timeout: config.timeout || 10000 })
        : await makeHttpRequest(variant.url, { timeout: config.timeout || 10000 });
      
      if (response.success && response.data) {
        results.push({
          ...variant,
          data: response.data,
          status: response.status
        });
        
        log('API', `Variant success: ${variant.source} for ${variant.keyword || variant.id || 'pagination'}`);
      } else {
        // Check for sites revealed in error
        const errorSites = extractSitesFromError(response);
        if (errorSites.length > 0) {
          log('API', `Error revealed sites: ${errorSites.join(', ')}`);
          results.push({
            ...variant,
            errorRevealed: errorSites,
            status: response.status
          });
        }
      }
      
      // Polite delay between requests
      await new Promise(r => setTimeout(r, delay));
      
    } catch (err) {
      log('ERR', `Variant failed: ${variant.url.substring(0, 60)}... - ${err.message}`);
    }
  }
  
  return results;
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  // Pattern types
  PATTERN_TYPES,
  
  // Pattern detection
  detectApiPatterns,
  
  // URL variant generation
  buildKeywordVariants,
  buildIdVariants,
  buildPaginationVariants,
  buildDateVariants,
  
  // Data extraction
  extractProviders,
  extractIds,
  extractSitesFromError,
  
  // API chaining
  chainApiCalls,
  executeVariants
};
